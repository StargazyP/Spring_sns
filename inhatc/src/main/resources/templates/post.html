<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>게시물 상세</title>
    <link rel="stylesheet" href="/css/sidebar.css" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background-color: #ffffff;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        color: #0f1419;
        line-height: 1.5;
        min-height: 100vh;
        padding: 0;
        margin: 0;
      }

      .wrapper {
        display: flex;
        max-width: 1200px;
        margin: 0 auto;
        background-color: #ffffff;
        min-height: 100vh;
      }


      /* 상단 헤더 (뒤로가기 버튼) */
      .top-header {
        position: sticky;
        top: 0;
        background-color: rgba(255, 255, 255, 0.85);
        backdrop-filter: blur(12px);
        border-bottom: 1px solid #eff3f4;
        padding: 16px 20px;
        display: flex;
        align-items: center;
        gap: 20px;
        z-index: 100;
        min-height: 64px;
      }

      .back-button {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background-color 0.2s;
        border: none;
        background: transparent;
        font-size: 20px;
        color: #0f1419;
      }

      .back-button:hover {
        background-color: #f7f9f9;
      }

      .header-title {
        font-size: 20px;
        font-weight: 700;
        color: #0f1419;
      }

      /* 게시물 상세 컨테이너 */
      .post-container {
        padding: 16px;
        border-bottom: 1px solid #eff3f4;
      }

      .post-header {
        display: flex;
        gap: 12px;
        margin-bottom: 16px;
      }

      .profile-img {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        object-fit: cover;
        flex-shrink: 0;
      }

      .post-header-info {
        flex: 1;
        min-width: 0;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .post-author {
        font-size: 20px;
        font-weight: 700;
        color: #0f1419;
        text-decoration: none;
        margin-bottom: 4px;
        display: block;
      }

      .post-author:hover {
        text-decoration: underline;
      }

      /* 팔로우 버튼 스타일 */
      .follow-btn {
        background-color: #0f1419;
        color: #ffffff;
        border: none;
        border-radius: 20px;
        padding: 8px 20px;
        font-size: 14px;
        font-weight: 700;
        cursor: pointer;
        transition: background-color 0.2s;
        margin-left: auto;
      }

      .follow-btn:hover {
        background-color: #272c30;
      }

      .follow-btn.following {
        background-color: #ffffff;
        color: #0f1419;
        border: 1px solid #eff3f4;
      }

      .follow-btn.following:hover {
        background-color: #f4212e;
        color: #ffffff;
        border-color: #f4212e;
      }

      .post-date {
        font-size: 15px;
        color: #536471;
      }

      .post-content {
        font-size: 15px;
        color: #0f1419;
        margin: 12px 0;
        line-height: 1.5;
        word-wrap: break-word;
      }

      .post-image {
        width: 100%;
        border-radius: 16px;
        margin: 12px 0;
        object-fit: cover;
      }

      .post-stats {
        color: #536471;
        font-size: 15px;
        margin-top: 12px;
      }

      .post-actions {
        display: flex;
        gap: 8px;
        margin-top: 16px;
        padding-top: 16px;
        border-top: 1px solid #eff3f4;
      }

      .action-button {
        background-color: transparent;
        color: #536471;
        border: 1px solid #eff3f4;
        border-radius: 20px;
        padding: 8px 16px;
        font-size: 15px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }

      .action-button:hover {
        background-color: #f7f9f9;
      }

      .action-button.liked {
        color: #f4212e;
        border-color: #f4212e;
      }

      .delete-button {
        background-color: #f4212e;
        color: #ffffff;
        border: none;
      }

      .delete-button:hover {
        background-color: #d91e2e;
      }

      /* YouTube 스타일 댓글 섹션 */
      .comment-section {
        padding: 24px 16px;
        border-top: 1px solid #e5e5e5;
        background-color: #ffffff;
      }

      .comment-section-title {
        font-size: 16px;
        font-weight: 500;
        color: #0f0f0f;
        margin-bottom: 24px;
      }

      .comments {
        margin-bottom: 16px;
        width: 100%;
        box-sizing: border-box;
      }

      /* YouTube 스타일 댓글 */
      .comment {
        display: flex;
        gap: 16px;
        padding: 16px 0;
        border-bottom: none;
        position: relative;
        width: 100%;
        box-sizing: border-box;
      }

      .comment:not(:last-child) {
        border-bottom: 1px solid #e5e5e5;
      }

      /* 스레드 구조 */
      .comment-thread {
        position: relative;
        padding-left: 0;
      }

      /* 스레드 연결선 */
      .comment-thread::before {
        content: '';
        position: absolute;
        left: 20px;
        top: 0;
        bottom: -12px;
        width: 2px;
        background-color: #eff3f4;
      }

      .comment-thread:last-child::before {
        display: none;
      }

      /* YouTube 스타일 - 불필요한 스타일 제거됨 */

      /* YouTube 스타일 프로필 이미지 */
      .comment .profile-img {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        flex-shrink: 0;
        object-fit: cover;
      }

      .comment-content {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      /* YouTube 스타일 작성자 정보 */
      .comment-author {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 4px;
      }

      .comment-author-name {
        font-weight: 500;
        font-size: 13px;
        color: #0f0f0f;
        line-height: 18px;
      }

      .comment-time {
        color: #606060;
        font-size: 12px;
        font-weight: 400;
      }

      .comment-text {
        font-size: 14px;
        color: #0f0f0f;
        margin: 0;
        line-height: 20px;
        word-wrap: break-word;
        white-space: pre-wrap;
      }

      /* YouTube 스타일 댓글 액션 */
      .comment-actions {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-top: 4px;
        padding-top: 4px;
      }

      /* YouTube 스타일 답글 버튼 */
      .reply-button {
        background-color: transparent;
        border: none;
        color: #606060;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        padding: 8px 16px;
        border-radius: 18px;
        display: flex;
        align-items: center;
        gap: 6px;
        transition: background-color 0.2s;
      }

      .reply-button:hover {
        background-color: #f2f2f2;
      }

      .reply-button svg {
        width: 16px;
        height: 16px;
      }

      /* 말풍선 버튼 제거됨 */

      .reply-text-button {
        background-color: transparent;
        border: none;
        color: #536471;
        font-size: 14px;
        cursor: pointer;
        padding: 4px 12px;
        border-radius: 20px;
        transition: all 0.2s;
        font-weight: 500;
      }

      .reply-text-button:hover {
        background-color: #f7f9f9;
        color: #0f1419;
      }

      /* YouTube 스타일 답글 보기 버튼 */
      .view-replies-button {
        background-color: transparent;
        border: none;
        color: #536471;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        padding: 8px 0;
        transition: color 0.2s;
        margin-top: 4px;
        align-self: flex-start;
        display: flex;
        align-items: center;
        gap: 6px;
        position: relative;
      }

      .view-replies-button:hover {
        color: #0f1419;
      }

      .view-replies-button::before {
        content: '▼';
        font-size: 10px;
        transition: transform 0.2s;
      }

      /* expanded 상태일 때 화살표 회전 */
      .view-replies-button.expanded::before {
        transform: rotate(180deg);
      }

      /* 대댓글 기본 숨김 - CSS로 처리 */
      .comment-reply.reply-hidden {
        display: none !important;
      }

      /* expanded 상태일 때 대댓글 표시 - CSS 클래스 기반 */
      .comment-reply:not(.reply-hidden) {
        display: flex !important;
      }

      /* 2번 이상 클릭 시 버튼 숨김 */
      .view-replies-button.hidden {
        display: none !important;
      }

      /* Thread View 관련 스타일 제거 (YouTube 스타일에서는 사용 안 함) */

      /* YouTube 스타일 대댓글 */
      .comment-reply {
        display: flex;
        gap: 16px;
        padding: 8px 0;
        margin-top: 8px;
        width: 100%;
        box-sizing: border-box;
        position: relative;
      }

      /* Node 연결선 효과 제거됨 */

      .comment-reply .profile-img {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        flex-shrink: 0;
        object-fit: cover;
      }

      .comment-reply .comment-content {
        gap: 6px;
      }

      .comment-reply .comment-author-name {
        font-size: 12px;
      }

      .comment-reply .comment-time {
        font-size: 11px;
      }

      .comment-reply .comment-text {
        font-size: 13px;
        line-height: 18px;
      }

      /* 답글 컨테이너는 더 이상 사용하지 않음 (같은 컨테이너에 렌더링) */
      .comment-replies-container {
        display: none; /* 숨김 처리 */
      }

      /* 스레드 스타일 제거 */
      .comment-thread {
        display: none; /* 숨김 처리 */
      }


      /* YouTube 스타일 긴 댓글 더보기 버튼 */
      .expand-comment-button {
        background-color: transparent;
        border: none;
        color: #065fd4;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        padding: 0;
        margin-left: 4px;
        text-decoration: none;
      }

      .expand-comment-button:hover {
        text-decoration: underline;
      }

      /* YouTube 스타일 Thread View */
      .thread-view {
        padding: 16px;
      }

      .thread-back-button {
        background-color: transparent;
        border: none;
        color: #065fd4;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        padding: 8px 0;
        margin-bottom: 16px;
        transition: color 0.2s;
      }

      .thread-back-button:hover {
        color: #0d0d0d;
      }

      /* 클릭 가능한 댓글 */
      .clickable-comment {
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .clickable-comment:hover {
        background-color: #f7f9f9;
      }

      /* YouTube 스타일 답글 작성 폼 */
      .reply-form {
        margin-top: 12px;
        padding: 0;
        display: none;
      }

      .reply-form.active {
        display: block;
      }

      .reply-textarea {
        width: 100%;
        padding: 8px 12px;
        border: none;
        border-bottom: 1px solid #e5e5e5;
        border-radius: 0;
        font-size: 14px;
        resize: none;
        outline: none;
        font-family: inherit;
        min-height: 40px;
        margin-bottom: 8px;
        background-color: transparent;
        color: #0f0f0f;
      }

      .reply-textarea:focus {
        border-bottom-color: #065fd4;
      }

      .reply-textarea::placeholder {
        color: #909090;
      }

      .reply-buttons {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        margin-top: 8px;
      }

      .reply-submit-button,
      .reply-cancel-button {
        padding: 10px 16px;
        border-radius: 18px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        border: none;
        transition: background-color 0.2s;
      }

      .reply-submit-button {
        background-color: #d1d5db;
        color: #0f1419;
      }

      .reply-submit-button:hover {
        background-color: #9ca3af;
      }

      .reply-cancel-button {
        background-color: transparent;
        color: #606060;
      }

      .reply-cancel-button:hover {
        background-color: #f2f2f2;
      }

      /* YouTube 스타일 댓글 작성 폼 */
      .comment-form {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-top: 16px;
      }

      .comment-textarea {
        width: 100%;
        padding: 12px;
        border: none;
        border-bottom: 1px solid #e5e5e5;
        border-radius: 0;
        font-size: 14px;
        resize: none;
        outline: none;
        font-family: inherit;
        min-height: 60px;
        background-color: transparent;
        color: #0f0f0f;
      }

      .comment-textarea:focus {
        border-bottom-color: #d1d5db;
      }

      .comment-textarea::placeholder {
        color: #909090;
      }

      .comment-submit-button {
        background-color: #d1d5db;
        color: #0f1419;
        border: none;
        border-radius: 18px;
        padding: 10px 16px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s;
        align-self: flex-end;
        width: auto;
      }

      .comment-submit-button:hover {
        background-color: #9ca3af;
      }

      .comment-submit-button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
      }

      .loading {
        text-align: center;
        padding: 60px 20px;
        color: #536471;
        font-size: 15px;
      }

      .error {
        text-align: center;
        padding: 60px 20px;
        color: #f4212e;
        font-size: 15px;
      }

      /* 로그인 모달 스타일 */
      .login-modal {
        display: none;
        position: fixed;
        z-index: 10000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        align-items: center;
        justify-content: center;
      }

      .login-modal-content {
        background-color: #ffffff;
        padding: 40px 32px;
        border-radius: 16px;
        max-width: 400px;
        width: 90%;
        position: relative;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
      }

      .login-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 32px;
      }

      .login-modal-header h2 {
        font-size: 31px;
        font-weight: 700;
        color: #0f1419;
        margin: 0;
      }

      .login-modal-close {
        color: #536471;
        font-size: 28px;
        font-weight: 300;
        cursor: pointer;
        line-height: 1;
      }

      .login-modal-close:hover {
        color: #0f1419;
      }

      .login-modal-content .form-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 20px;
      }

      .login-modal-content label {
        font-size: 15px;
        font-weight: 500;
        color: #0f1419;
      }

      .login-modal-content input[type="email"],
      .login-modal-content input[type="password"] {
        width: 100%;
        padding: 12px 16px;
        border: 1px solid #eff3f4;
        border-radius: 8px;
        font-size: 15px;
        font-family: inherit;
        color: #0f1419;
        background-color: #ffffff;
        transition: border-color 0.2s;
        outline: none;
      }

      .login-modal-content input[type="email"]:focus,
      .login-modal-content input[type="password"]:focus {
        border-color: #1d9bf0;
      }

      .login-modal-content button[type="submit"] {
        width: 100%;
        padding: 12px 24px;
        background-color: #0f1419;
        color: #ffffff;
        border: none;
        border-radius: 24px;
        font-size: 15px;
        font-weight: 700;
        cursor: pointer;
        transition: background-color 0.2s;
        margin-top: 8px;
      }

      .login-modal-content button[type="submit"]:hover {
        background-color: #272c30;
      }

      .login-modal-content .error {
        color: #f4212e;
        text-align: center;
        margin-top: 16px;
        font-size: 15px;
        padding: 12px;
        background-color: #f7f9f9;
        border-radius: 8px;
        border: 1px solid #eff3f4;
      }

      .login-modal-content .signup-link {
        text-align: center;
        margin-top: 24px;
        font-size: 15px;
        color: #536471;
      }

      .login-modal-content .signup-link a {
        color: #1d9bf0;
        text-decoration: none;
        font-weight: 500;
      }

      .login-modal-content .signup-link a:hover {
        text-decoration: underline;
      }

      /* 반응형 디자인 */
      @media (max-width: 768px) {
        .wrapper {
          max-width: 100%;
          border-left: none;
          border-right: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <!-- 왼쪽 사이드바 (X.com 스타일) -->
      <div class="sidebar">
        <a href="/main" class="sidebar-item">
          <img src="/images/home.png" alt="home" />
          <span>Home</span>
        </a>
        <a href="/member/mypage" class="sidebar-item">
          <img src="/images/user.png" alt="User" />
          <span>User</span>
        </a>
        <a href="/chat/message" class="sidebar-item">
          <img src="/Message.png" alt="Message" />
          <span>Message</span>
        </a>
        <div class="sidebar-item" onclick="location.href='/posts/notifications/page';" style="cursor: pointer;">
          <img src="/images/alram.png" alt="Alarm" />
          <span>Alarm</span>
        </div>
        <div class="sidebar-item" onclick="document.getElementById('logout').submit();" style="cursor: pointer;">
          <img src="/images/logout.png" alt="Logout" />
          <span>Logout</span>
        </div>
        <form id="logout" action="/api/members/logout" method="post"></form>
      </div>

      <!-- 메인 컨텐츠 영역 -->
      <div class="main-content">
        <!-- 상단 헤더 (뒤로가기 버튼) -->
        <div class="top-header">
          <button class="back-button" onclick="goBack()">←</button>
          <div class="header-title">게시물</div>
      </div>

      <!-- 게시물 상세 영역 -->
      <div id="postContainer" class="post-container">
        <div class="loading">게시물을 불러오는 중...</div>
      </div>

      <!-- 댓글 섹션 -->
      <div class="comment-section">
        <div class="comment-section-title">댓글</div>
        <div id="comments" class="comments">
          <!-- 댓글이 여기에 동적으로 추가됩니다 -->
        </div>
        <div class="comment-form">
          <textarea
            id="commentContent"
            class="comment-textarea"
            placeholder="댓글을 입력하세요"
          ></textarea>
          <button class="comment-submit-button" onclick="submitComment()">댓글 등록</button>
        </div>
        </div>
      </div>
    </div>

    <!-- 로그인 모달 -->
    <div id="loginModal" class="login-modal" style="display: none;">
      <div class="login-modal-content">
        <div class="login-modal-header">
          <h2>로그인</h2>
          <span class="login-modal-close" onclick="closeLoginModal()">&times;</span>
        </div>
        <form id="loginForm" onsubmit="handleLogin(event)">
          <div class="form-group">
            <label for="modalEmail">이메일</label>
            <input type="email" id="modalEmail" name="email" placeholder="이메일을 입력하세요" required>
          </div>
          <div class="form-group">
            <label for="modalPassword">비밀번호</label>
            <input type="password" id="modalPassword" name="password" placeholder="비밀번호를 입력하세요" required>
          </div>
          <div id="loginError" class="error" style="display: none;"></div>
          <button type="submit">로그인</button>
        </form>
        <div class="signup-link">
          계정이 없으신가요? <a href="/api/members/signup">회원가입</a>
        </div>
      </div>
    </div>

    <script type="text/javascript">
      let currentPostId = null;
      let currentPost = null;

      // 로그인 상태 확인
      async function checkLoginStatus() {
        try {
          const response = await fetch("/api/members/session", {
            credentials: "include"
          });
          if (response.ok) {
            const data = await response.json();
            return data.loginEmail != null;
          }
        } catch (error) {
          console.error("로그인 상태 확인 오류:", error);
        }
        return false;
      }

      // 로그인 모달 열기
      function openLoginModal() {
        const modal = document.getElementById("loginModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      // 로그인 모달 닫기
      function closeLoginModal() {
        const modal = document.getElementById("loginModal");
        if (modal) {
          modal.style.display = "none";
          document.getElementById("loginError").style.display = "none";
          document.getElementById("loginForm").reset();
        }
      }

      // 로그인 처리
      async function handleLogin(event) {
        event.preventDefault();
        const form = event.target;
        const formData = new FormData(form);
        const errorDiv = document.getElementById("loginError");

        try {
          const response = await fetch("/api/members/login", {
            method: "POST",
            body: formData,
            credentials: "include"
          });

          if (response.ok) {
            closeLoginModal();
            location.reload();
          } else {
            const errorText = await response.text();
            errorDiv.textContent = errorText || "로그인에 실패했습니다.";
            errorDiv.style.display = "block";
          }
        } catch (error) {
          errorDiv.textContent = "로그인 중 오류가 발생했습니다.";
          errorDiv.style.display = "block";
        }
      }

      // 모달 외부 클릭 시 닫기
      window.onclick = function(event) {
        const modal = document.getElementById("loginModal");
        if (event.target === modal) {
          closeLoginModal();
        }
      };

      // 댓글 작성 폼 포커스 시 로그인 체크
      document.addEventListener('DOMContentLoaded', function() {
        const commentTextarea = document.getElementById('commentContent');
        if (commentTextarea) {
          commentTextarea.addEventListener('focus', async function() {
            const isLoggedIn = await checkLoginStatus();
            if (!isLoggedIn) {
              this.blur();
              openLoginModal();
            }
          });
        }
      });

      // 페이지 로드 시 게시물 정보 가져오기
      window.onload = async function () {
        const postId = getPostIdFromUrl();
        if (!postId) {
          showError("게시물 ID를 찾을 수 없습니다.");
          return;
        }

        currentPostId = postId;
        await loadPost(postId);
        await loadComments(postId, 0, false);
      };

      // URL에서 게시물 ID 추출
      function getPostIdFromUrl() {
        const pathParts = window.location.pathname.split("/");
        const postId = pathParts[pathParts.length - 1];
        // 공백 및 특수 문자 제거 및 검증
        const cleanedPostId = postId ? postId.trim().replace(/[^a-zA-Z0-9_-]/g, '') : null;
        console.log("Extracted postId:", cleanedPostId);
        return cleanedPostId;
      }

      // 뒤로 가기
      function goBack() {
        window.history.back();
      }

      // 게시물 로드
      async function loadPost(postId) {
        if (!postId || postId.trim() === '') {
          showError("유효하지 않은 게시물 ID입니다.");
          return;
        }
        try {
          // URL 안전하게 인코딩
          const encodedPostId = encodeURIComponent(postId.trim());
          const response = await fetch(`/api/posts/${encodedPostId}`);
          
          if (!response.ok) {
            if (response.status === 404) {
              showError("게시물을 찾을 수 없습니다.");
            } else {
              showError("게시물을 불러오는 중 오류가 발생했습니다.");
            }
            return;
          }

          const post = await response.json();
          currentPost = post;
          renderPost(post);
        } catch (error) {
          console.error("게시물 로드 오류:", error);
          showError("게시물을 불러오는 중 오류가 발생했습니다.");
        }
      }

      // 게시물 렌더링
      async function renderPost(post) {
        const container = document.getElementById("postContainer");
        
        const memberEmail = await getMemberEmail();
        const isOwner = memberEmail && post.writerEmail === memberEmail;

        const followButtonHtml = !isOwner ? `
          <button class="follow-btn" id="followButton" onclick="toggleFollow()">
            팔로우
          </button>
        ` : '';

        const postHtml = `
          <div class="post-header">
            <img 
              src="${post.profilePicturePath || '/images/default-profile.png'}" 
              class="profile-img"
              onerror="this.src='/images/default-profile.png';"
            />
            <div class="post-header-info">
              <div>
              <a href="/member/profile/${encodeURIComponent(post.writerEmail)}" class="post-author">
                ${post.writerName || "(이름 없음)"}
              </a>
              <div class="post-date">${new Date(post.createdDate).toLocaleString("ko-KR")}</div>
              </div>
              ${followButtonHtml}
            </div>
          </div>
          <div class="post-content">${post.content || ""}</div>
          ${post.imgsource ? `<img src="${post.imgsource}" class="post-image" onerror="this.style.display='none';">` : ""}
          <div class="post-stats">조회수: ${post.hits || 0}</div>
          <div class="post-actions">
            <button class="action-button" id="likeButton" onclick="toggleLike()">
              ❤️ ${post.love || 0}
            </button>
            ${isOwner ? `<button class="action-button delete-button" onclick="deletePost()">삭제</button>` : ""}
          </div>
        `;

        container.innerHTML = postHtml;

        // 좋아요 상태 확인 및 업데이트
        if (memberEmail) {
          checkLikeStatus(post.id, memberEmail);
        }

        // 팔로우 상태 확인 및 업데이트 (본인 게시글이 아닐 때만)
        if (!isOwner && memberEmail) {
          checkFollowStatus(post.writerEmail);
        }
      }

      // 에러 표시
      function showError(message) {
        const container = document.getElementById("postContainer");
        container.innerHTML = `<div class="error">${message}</div>`;
      }

      // 로그인된 사용자 이메일 가져오기
      async function getMemberEmail() {
        try {
          const response = await fetch("/api/members/session", {
            credentials: "include",
          });

          if (!response.ok) {
            return null;
          }

          const data = await response.json();
          return data.loginEmail || null;
        } catch (error) {
          console.error("세션 정보 가져오기 오류:", error);
          return null;
        }
      }

      // 좋아요 상태 확인
      async function checkLikeStatus(postId, email) {
        // 좋아요 상태를 확인하는 API가 있다면 사용
        // 현재는 기본 상태로 표시
      }

      // 좋아요 토글
      async function toggleLike() {
        const userEmail = await getMemberEmail();
        if (!userEmail) {
          alert("로그인이 필요합니다.");
          return;
        }

        const button = document.getElementById("likeButton");
        const currentText = button.textContent;
        const currentCount = parseInt(currentText.match(/\d+/)?.[0] || "0");

        try {
          if (!currentPostId || currentPostId.trim() === '') {
            alert("유효하지 않은 게시물 ID입니다.");
            return;
          }
          const encodedPostId = encodeURIComponent(currentPostId.trim());
          const response = await fetch(
            `/api/posts/${encodedPostId}/likes?email=${encodeURIComponent(userEmail)}`,
            { method: "POST" }
          );

          if (!response.ok) {
            throw new Error("좋아요 처리 실패");
          }

          const data = await response.json();
          
          if (data.liked) {
            button.textContent = `❤️ ${currentCount + 1}`;
            button.classList.add("liked");
          } else {
            button.textContent = `❤️ ${currentCount - 1}`;
            button.classList.remove("liked");
          }
        } catch (error) {
          console.error("좋아요 오류:", error);
          alert("좋아요 처리 중 오류가 발생했습니다.");
        }
      }

      // 게시물 삭제
      async function deletePost() {
        if (!confirm("게시물을 삭제하시겠습니까?")) {
          return;
        }

        try {
          if (!currentPostId || currentPostId.trim() === '') {
            alert("유효하지 않은 게시물 ID입니다.");
            return;
          }
          const encodedPostId = encodeURIComponent(currentPostId.trim());
          const response = await fetch(`/api/posts/${encodedPostId}`, {
            method: "DELETE",
          });

          if (!response.ok) {
            throw new Error("게시물 삭제 실패");
          }

          alert("게시물이 삭제되었습니다.");
          window.location.href = "/main";
        } catch (error) {
          console.error("삭제 오류:", error);
          alert("게시물 삭제 중 오류가 발생했습니다.");
        }
      }

      // =====================================================
      // 팔로우 기능
      // =====================================================
      // 팔로우 상태 확인
      async function checkFollowStatus(writerEmail) {
        try {
          const memberEmail = await getMemberEmail();
          if (!memberEmail || memberEmail === writerEmail) {
            return;
          }

          const response = await fetch(`/api/follow/${encodeURIComponent(writerEmail)}/status`);
          if (response.ok) {
            const isFollowing = await response.json();
            const button = document.getElementById('followButton');
            if (button) {
              updateFollowButton(button, isFollowing);
            }
          }
        } catch (error) {
          console.error('팔로우 상태 확인 중 오류:', error);
        }
      }

      // 팔로우 버튼 상태 업데이트 (텍스트 및 hover 처리)
      function updateFollowButton(button, isFollowing) {
        if (isFollowing) {
          button.classList.add('following');
          button.textContent = '팔로잉';
          
          // hover 이벤트가 없으면 추가 (한 번만)
          if (!button.hasAttribute('data-hover-bound')) {
            button.setAttribute('data-hover-bound', 'true');
            button.addEventListener('mouseenter', function() {
              if (this.classList.contains('following')) {
                this.textContent = '언팔로우';
              }
            });
            
            button.addEventListener('mouseleave', function() {
              if (this.classList.contains('following')) {
                this.textContent = '팔로잉';
              }
            });
          }
        } else {
          button.classList.remove('following');
          button.textContent = '팔로우';
        }
      }

      // 팔로우/언팔로우 토글
      async function toggleFollow() {
        try {
          if (!currentPost || !currentPost.writerEmail) {
            alert('게시물 정보를 찾을 수 없습니다.');
            return;
          }

          const writerEmail = currentPost.writerEmail;
          const memberEmail = await getMemberEmail();
          
          if (!memberEmail) {
            alert('로그인이 필요합니다.');
            return;
          }

          if (memberEmail === writerEmail) {
            alert('자기 자신을 팔로우할 수 없습니다.');
            return;
          }

          const button = document.getElementById('followButton');
          if (!button) {
            return;
          }

          const isFollowing = button.classList.contains('following');
          const url = isFollowing 
            ? `/api/follow/${encodeURIComponent(writerEmail)}/unfollow`
            : `/api/follow/${encodeURIComponent(writerEmail)}`;

          const response = await fetch(url, {
            method: 'POST',
            credentials: 'include'
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(errorText || '팔로우 처리 중 오류가 발생했습니다.');
          }

          // 버튼 상태 업데이트
          const newFollowingState = !isFollowing;
          updateFollowButton(button, newFollowingState);
        } catch (error) {
          console.error('팔로우 처리 중 오류:', error);
          alert(error.message || '팔로우 처리 중 오류가 발생했습니다.');
        }
      }

      // =====================================================
      // 댓글 시스템 (DFS 기반 Node 구조)
      // =====================================================
      
      // CommentNode 클래스 - 댓글을 Node로 표현
      class CommentNode {
        constructor(commentData) {
          this.id = commentData.id;
          this.comment = commentData.comment;
          this.writerName = commentData.writerName;
          this.writerProfile = commentData.writerProfile || "/images/default-profile.png";
          this.createDate = commentData.createDate;
          this.parentCommentId = commentData.parentCommentId;
          this.children = []; // 자식 댓글들 (대댓글)
          this.depth = 0; // 트리 깊이
          this.data = commentData; // 원본 데이터 보관
        }
        
        addChild(childNode) {
          childNode.depth = this.depth + 1;
          this.children.push(childNode);
        }
        
        // 자식 개수 (재귀적으로 모든 하위 댓글 포함)
        getTotalReplyCount() {
          let count = this.children.length;
          this.children.forEach(child => {
            count += child.getTotalReplyCount();
          });
          return count;
        }
      }
      
      // 평면 배열을 트리 구조로 변환 (Node 기반)
      function buildCommentTree(comments) {
        if (!comments || comments.length === 0) return [];
        
        // replies 배열이 있는 경우 평면 배열로 변환
        function flattenReplies(comments) {
          const flatList = [];
          comments.forEach(comment => {
            flatList.push(comment);
            if (comment.replies && Array.isArray(comment.replies) && comment.replies.length > 0) {
              // replies 배열의 각 항목에 parentCommentId 설정
              comment.replies.forEach(reply => {
                if (!reply.parentCommentId) {
                  reply.parentCommentId = comment.id;
                }
              });
              flatList.push(...flattenReplies(comment.replies));
            }
          });
          return flatList;
        }
        
        // replies 배열이 있는지 확인
        const hasRepliesArray = comments.some(comment => comment.replies && Array.isArray(comment.replies));
        const flatComments = hasRepliesArray ? flattenReplies(comments) : comments;
        
        const nodeMap = new Map(); // id -> CommentNode 매핑
        const rootNodes = []; // 루트 노드들 (parentCommentId가 null인 것들)
        
        // 1단계: 모든 댓글을 Node로 변환
        flatComments.forEach(comment => {
          const node = new CommentNode(comment);
          nodeMap.set(comment.id, node);
        });
        
        // 2단계: 부모-자식 관계 설정
        flatComments.forEach(comment => {
          const node = nodeMap.get(comment.id);
          
          if (comment.parentCommentId) {
            // 부모가 있으면 부모의 자식으로 추가
            const parentNode = nodeMap.get(comment.parentCommentId);
            if (parentNode) {
              parentNode.addChild(node);
            } else {
              // 부모를 찾을 수 없으면 루트로 처리 (데이터 불일치 방지)
              rootNodes.push(node);
            }
          } else {
            // 부모가 없으면 루트 노드
            rootNodes.push(node);
          }
        });
        
        // 3단계: 각 노드의 자식들을 시간순으로 정렬
        function sortChildrenRecursive(node) {
          node.children.sort((a, b) => {
            const dateA = a.createDate ? new Date(a.createDate).getTime() : 0;
            const dateB = b.createDate ? new Date(b.createDate).getTime() : 0;
            return dateA - dateB;
          });
          
          node.children.forEach(child => sortChildrenRecursive(child));
        }
        
        rootNodes.forEach(root => sortChildrenRecursive(root));
        
        return rootNodes;
      }
      
      // 댓글 로드 (무한 스크롤 지원)
      let currentPage = 0;
      let isLoadingComments = false;
      let hasMoreComments = true;
      let currentThreadCommentId = null; // Thread View에서 보는 댓글 ID
      const pageSize = 20;
      let commentTree = []; // 전체 댓글 트리 저장
      let allCommentsFlat = []; // 모든 댓글과 대댓글을 평면 배열로 저장 (무한 스크롤용)

      async function loadComments(postId, page = 0, isThreadView = false) {
        if (isLoadingComments) return;
        
        try {
          isLoadingComments = true;
          
          // 기본 화면에서는 all=true로 전체 댓글을 가져와서 replies 포함
          // Thread View가 아닐 때는 all=true 사용
          let response;
          if (!postId || postId.trim() === '') {
            console.error("유효하지 않은 postId:", postId);
            return;
          }
          const encodedPostId = encodeURIComponent(postId.trim());
          if (!isThreadView) {
            // 전체 댓글을 가져와서 replies 포함
            response = await fetch(`/api/posts/${encodedPostId}/comments?all=true`);
          } else {
            // Thread View일 때는 페이징 사용
            response = await fetch(`/api/posts/${encodedPostId}/comments?page=${page}&size=${pageSize}&sort=createDate,desc`);
          }
          
          if (!response.ok) {
            console.error("댓글 로드 실패");
            return;
          }

          const responseData = await response.json();
          let comments;
          let totalPages = 1;
          
          if (isThreadView) {
            comments = Array.isArray(responseData) ? responseData : (responseData.content || []);
            totalPages = responseData.totalPages || 1;
            hasMoreComments = page < totalPages - 1;
            currentPage = page;
          } else {
            // all=true일 때는 배열로 반환
            comments = Array.isArray(responseData) ? responseData : [];
            hasMoreComments = false; // 전체 로드이므로 더 이상 없음
            currentPage = 0;
          }
          
          // 평면 배열을 트리 구조로 변환 (Node 기반)
          commentTree = buildCommentTree(comments);
          
          // Thread View인 경우
          if (isThreadView && currentThreadCommentId) {
            showThreadView(currentThreadCommentId, comments);
            return;
          }
          
          // 트리를 평면 배열로 변환 (댓글 + 대댓글 모두 포함, 순차적으로)
          if (page === 0 || !isThreadView) {
            allCommentsFlat = flattenCommentTree(commentTree);
          }
          
          // 기본 화면: 댓글과 대댓글을 같은 컨테이너에 표시
          const container = document.getElementById("comments");
          if (!container) return;
          
          if (page === 0 || !isThreadView) {
            container.innerHTML = "";
            currentPage = 0;
          }
          
          if (!allCommentsFlat || allCommentsFlat.length === 0) {
            if (container.children.length === 0) {
              container.innerHTML = "<div style='text-align: center; padding: 20px; color: #536471;'>댓글이 없습니다.</div>";
            }
            hasMoreComments = false;
            return;
          }
          
          // 페이징 처리: 평면 배열에서 현재 페이지에 해당하는 댓글들만 렌더링
          const startIndex = currentPage * pageSize;
          const endIndex = Math.min(startIndex + pageSize, allCommentsFlat.length);
          const commentsToRender = allCommentsFlat.slice(startIndex, endIndex);
          
          // 같은 컨테이너에 댓글과 대댓글을 순차적으로 렌더링 (card1, card2, card3...)
          commentsToRender.forEach((node) => {
            renderCommentNodeFlat(container, node);
          });
          
          // 무한 스크롤 가능 여부 업데이트
          hasMoreComments = endIndex < allCommentsFlat.length;
          currentPage = 1; // 다음 페이지는 1부터
          
          // 무한 스크롤 설정
            setupInfiniteScroll();
        } catch (error) {
          console.error("댓글 로드 오류:", error);
        } finally {
          isLoadingComments = false;
        }
      }

      // 다음 페이지 댓글 로드 (평면 배열에서 다음 페이지 로드)
      async function loadMoreComments() {
        if (!hasMoreComments || isLoadingComments || currentThreadCommentId) return;
        
        // 평면 배열에서 다음 페이지 렌더링
        const container = document.getElementById("comments");
        if (!container || !allCommentsFlat || allCommentsFlat.length === 0) return;
        
        const startIndex = currentPage * pageSize;
        const endIndex = Math.min(startIndex + pageSize, allCommentsFlat.length);
        
        if (startIndex >= allCommentsFlat.length) {
          hasMoreComments = false;
          return;
        }
        
        const commentsToRender = allCommentsFlat.slice(startIndex, endIndex);
        
        // 같은 컨테이너에 댓글과 대댓글을 순차적으로 렌더링 (card1, card2, card3...)
        commentsToRender.forEach((node) => {
          renderCommentNodeFlat(container, node);
        });
        
        hasMoreComments = endIndex < allCommentsFlat.length;
        currentPage++;
      }

      // 댓글 ID로 댓글 찾기 (재귀)
      function findCommentById(comments, commentId) {
        for (const comment of comments) {
          if (comment.id === commentId) {
            return comment;
          }
          if (comment.replies && comment.replies.length > 0) {
            const found = findCommentById(comment.replies, commentId);
            if (found) return found;
          }
        }
        return null;
      }

      // 메인 댓글 렌더링 (답글 포함)
      function renderMainComment(container, comment) {
        const mainCommentDiv = document.createElement("div");
        mainCommentDiv.className = "comment-main-view";
        mainCommentDiv.setAttribute("data-comment-id", comment.id);

        const mainContent = document.createElement("div");
        mainContent.className = "comment";
        
        const img = document.createElement("img");
        img.className = "profile-img";
        img.src = comment.writerProfile || "/images/default-profile.png";
        img.onerror = function() {
          this.src = "/images/default-profile.png";
        };

        const contentDiv = document.createElement("div");
        contentDiv.className = "comment-content";
        
        const authorDiv = document.createElement("div");
        authorDiv.className = "comment-author";
        authorDiv.textContent = comment.writerName || "(이름 없음)";
        
        const textP = document.createElement("p");
        textP.className = "comment-text";
        textP.textContent = comment.comment;

        const actionsDiv = document.createElement("div");
        actionsDiv.className = "comment-actions";
        
        // 답글 아이콘 버튼
        const replyIconButton = document.createElement("button");
        replyIconButton.className = "reply-button";
        replyIconButton.innerHTML = `<svg class="reply-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.15 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></svg>`;
        replyIconButton.onclick = function(e) {
          e.stopPropagation();
          toggleReplyForm(comment.id);
        };
        actionsDiv.appendChild(replyIconButton);

        // 답글 작성 폼
        const replyForm = createReplyForm(comment.id);
        
        contentDiv.appendChild(authorDiv);
        contentDiv.appendChild(textP);
        contentDiv.appendChild(actionsDiv);
        contentDiv.appendChild(replyForm);

        mainContent.appendChild(img);
        mainContent.appendChild(contentDiv);
        mainCommentDiv.appendChild(mainContent);

        // 대댓글 컨테이너 제거 - 같은 컨테이너에 평면적으로 렌더링하므로 불필요

        container.appendChild(mainCommentDiv);
      }


      // 평면 배열로 댓글 렌더링 (같은 컨테이너에 댓글과 대댓글 모두)
      function renderCommentNodeFlat(container, node) {
        if (!node) return;
        
        const isReply = node.depth > 0;
        const commentDiv = document.createElement("div");
        commentDiv.className = isReply ? "comment comment-reply" : "comment";
        commentDiv.setAttribute("data-comment-id", node.id);
        commentDiv.setAttribute("data-depth", node.depth);
        commentDiv.setAttribute("data-parent-id", node.parentCommentId || "");
        
        // 들여쓰기 제거 - 모든 댓글/대댓글을 같은 레벨에서 표시
        
        const img = document.createElement("img");
        img.className = "profile-img";
        img.src = node.writerProfile || "/images/default-profile.png";
        img.onerror = function() {
          this.src = "/images/default-profile.png";
        };

        const contentDiv = document.createElement("div");
        contentDiv.className = "comment-content";
        
        const authorDiv = document.createElement("div");
        authorDiv.className = "comment-author";
        
        const authorNameSpan = document.createElement("span");
        authorNameSpan.className = "comment-author-name";
        authorNameSpan.textContent = node.writerName || "(이름 없음)";
        
        const timeSpan = document.createElement("span");
        timeSpan.className = "comment-time";
        const createdDate = node.createDate ? new Date(node.createDate) : new Date();
        timeSpan.textContent = getTimeAgo(createdDate);
        
        authorDiv.appendChild(authorNameSpan);
        authorDiv.appendChild(timeSpan);
        
        // 긴 댓글 처리
        const textP = document.createElement("p");
        textP.className = "comment-text";
        const maxLength = 200;
        const fullText = node.comment;
        if (fullText.length > maxLength) {
          const shortText = fullText.substring(0, maxLength);
          textP.innerHTML = `<span class="comment-text-short">${shortText}...</span><span class="comment-text-full" style="display:none">${fullText}</span>`;
          
          const expandButton = document.createElement("button");
          expandButton.className = "expand-comment-button";
          expandButton.textContent = "더보기";
          expandButton.onclick = function(e) {
            e.stopPropagation();
            const shortSpan = textP.querySelector(".comment-text-short");
            const fullSpan = textP.querySelector(".comment-text-full");
            if (shortSpan && fullSpan) {
              if (shortSpan.style.display !== "none") {
                shortSpan.style.display = "none";
                fullSpan.style.display = "inline";
                expandButton.textContent = "숨기기";
              } else {
                shortSpan.style.display = "inline";
                fullSpan.style.display = "none";
                expandButton.textContent = "더보기";
              }
            }
          };
          textP.appendChild(expandButton);
        } else {
          textP.textContent = fullText;
        }

        const actionsDiv = document.createElement("div");
        actionsDiv.className = "comment-actions";
        
        // 원본 댓글(depth: 0)만 답글 작성 버튼 표시, 대댓글(depth > 0)에는 표시 안 함
        if (!isReply) {
          // 답글 아이콘 버튼
          const replyIconButton = document.createElement("button");
          replyIconButton.className = "reply-button";
          replyIconButton.innerHTML = `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.15 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></svg>`;
          replyIconButton.onclick = function(e) {
            e.stopPropagation();
            toggleReplyForm(node.id);
          };
          actionsDiv.appendChild(replyIconButton);
        }
        
        contentDiv.appendChild(authorDiv);
        contentDiv.appendChild(textP);
        contentDiv.appendChild(actionsDiv);
        
        // 원본 댓글(depth: 0)만 답글 작성 폼 표시
        if (!isReply) {
          const replyForm = createReplyForm(node.id);
          contentDiv.appendChild(replyForm);
        }
        
        // 대댓글이 있는 경우 "답글 보기" 버튼 추가 (원본 댓글만)
        if (!isReply && node.children.length > 0) {
          const viewRepliesButton = document.createElement("button");
          viewRepliesButton.className = "view-replies-button";
          viewRepliesButton.setAttribute("data-parent-id", node.id);
          const totalReplies = node.getTotalReplyCount();
          viewRepliesButton.textContent = `답글 ${totalReplies}개 보기`;
          viewRepliesButton.onclick = function(e) {
            e.stopPropagation();
            toggleRepliesVisibility(node.id, viewRepliesButton);
          };
          contentDiv.appendChild(viewRepliesButton);
        }

        commentDiv.appendChild(img);
        commentDiv.appendChild(contentDiv);
        
        // 대댓글은 기본적으로 숨김 처리
        // 단, 부모가 이미 expanded 상태이면 표시 (모든 depth의 대댓글 포함)
        if (isReply) {
          // 부모 댓글이 expanded 상태인지 확인 (재귀적으로 상위 부모도 확인)
          let shouldShow = false;
          let currentParentId = node.parentCommentId;
          
          // 상위 부모들을 재귀적으로 확인
          while (currentParentId) {
            const parentElement = container.querySelector(`[data-comment-id="${currentParentId}"]`);
            if (parentElement && parentElement.classList.contains("expanded")) {
              shouldShow = true;
              break;
            }
            // 부모의 부모 찾기
            if (parentElement) {
              currentParentId = parentElement.getAttribute("data-parent-id");
            } else {
              break;
            }
          }
          
          if (shouldShow) {
            // 상위 부모가 expanded이면 표시
            commentDiv.classList.remove("reply-hidden");
          } else {
            // 상위 부모가 expanded가 아니면 숨김
            commentDiv.classList.add("reply-hidden");
          }
        }
        
        container.appendChild(commentDiv);
      }

      // 댓글과 자식 대댓글을 재귀적으로 같은 container에 렌더링
      function renderCommentNodeWithChildren(container, node) {
        if (!node) return;
        
        // 현재 노드 렌더링
        renderCommentNodeFlat(container, node);
        
        // 자식 대댓글들도 같은 container에 재귀적으로 렌더링
        if (node.children && node.children.length > 0) {
          node.children.forEach((childNode) => {
            renderCommentNodeWithChildren(container, childNode);
          });
        }
      }

      // 클릭 횟수 추적을 위한 Map
      const replyClickCount = new Map();

      // 대댓글 표시/숨김 토글 함수 (재귀적으로 모든 depth의 대댓글 처리)
      function toggleRepliesVisibility(parentCommentId, button) {
        const container = document.getElementById("comments");
        if (!container) return;
        
        // 재귀적으로 모든 하위 대댓글 찾기 (모든 depth 포함)
        function getAllChildReplies(parentId) {
          const allReplies = [];
          const directChildren = Array.from(container.querySelectorAll(`[data-parent-id="${parentId}"]`));
          
          directChildren.forEach(child => {
            allReplies.push(child);
            const childId = child.getAttribute("data-comment-id");
            if (childId) {
              // 재귀적으로 자식의 자식도 모두 찾기
              allReplies.push(...getAllChildReplies(childId));
            }
          });
          
          return allReplies;
        }
        
        // 부모 댓글 요소 찾기
        const parentComment = container.querySelector(`[data-comment-id="${parentCommentId}"]`);
        if (!parentComment) return;
        
        // CSS 클래스로 토글
        const isExpanded = parentComment.classList.contains("expanded");
        
        if (isExpanded) {
          // 숨김 처리 - 모든 하위 대댓글 숨김
          parentComment.classList.remove("expanded");
          const allReplies = getAllChildReplies(parentCommentId);
          allReplies.forEach((reply) => {
            reply.classList.add("reply-hidden");
          });
          if (button) {
            const totalReplies = allReplies.length;
            button.textContent = `답글 ${totalReplies}개 보기`;
            button.classList.remove("expanded");
          }
        } else {
          // 표시 처리 - 모든 하위 대댓글 표시 (재귀적으로)
          parentComment.classList.add("expanded");
          const allReplies = getAllChildReplies(parentCommentId);
          allReplies.forEach((reply) => {
            reply.classList.remove("reply-hidden");
            // 자식 대댓글이 있으면 부모도 expanded 상태로 만들어서 표시
            const replyId = reply.getAttribute("data-comment-id");
            if (replyId) {
              const hasChildren = container.querySelectorAll(`[data-parent-id="${replyId}"]`).length > 0;
              if (hasChildren) {
                reply.classList.add("expanded");
              }
            }
          });
          if (button) {
            button.textContent = `답글 숨기기`;
            button.classList.add("expanded");
          }
        }
      }

      // DFS로 댓글 Node 렌더링 (깊이 우선 탐색) - 호환성 유지
      function renderCommentNodeDFS(container, node, showChildren = false, isReply = false) {
        if (!node) return;
        
        // 현재 노드 렌더링
        const commentDiv = document.createElement("div");
        commentDiv.className = isReply ? "comment comment-reply" : "comment";
        commentDiv.setAttribute("data-comment-id", node.id);
        commentDiv.setAttribute("data-depth", node.depth);
        
        const img = document.createElement("img");
        img.className = "profile-img";
        img.src = node.writerProfile || "/images/default-profile.png";
        img.onerror = function() {
          this.src = "/images/default-profile.png";
        };

        const contentDiv = document.createElement("div");
        contentDiv.className = "comment-content";
        
        const authorDiv = document.createElement("div");
        authorDiv.className = "comment-author";
        
        const authorNameSpan = document.createElement("span");
        authorNameSpan.className = "comment-author-name";
        authorNameSpan.textContent = node.writerName || "(이름 없음)";
        
        const timeSpan = document.createElement("span");
        timeSpan.className = "comment-time";
        const createdDate = node.createDate ? new Date(node.createDate) : new Date();
        timeSpan.textContent = getTimeAgo(createdDate);
        
        authorDiv.appendChild(authorNameSpan);
        authorDiv.appendChild(timeSpan);
        
        // 긴 댓글 처리
        const textP = document.createElement("p");
        textP.className = "comment-text";
        const maxLength = 200;
        const fullText = node.comment;
        if (fullText.length > maxLength) {
          const shortText = fullText.substring(0, maxLength);
          textP.innerHTML = `<span class="comment-text-short">${shortText}...</span><span class="comment-text-full" style="display:none">${fullText}</span>`;
          
          const expandButton = document.createElement("button");
          expandButton.className = "expand-comment-button";
          expandButton.textContent = "더보기";
          expandButton.onclick = function(e) {
            e.stopPropagation();
            const shortSpan = textP.querySelector(".comment-text-short");
            const fullSpan = textP.querySelector(".comment-text-full");
            if (shortSpan && fullSpan) {
              if (shortSpan.style.display !== "none") {
                shortSpan.style.display = "none";
                fullSpan.style.display = "inline";
                expandButton.textContent = "숨기기";
              } else {
                shortSpan.style.display = "inline";
                fullSpan.style.display = "none";
                expandButton.textContent = "더보기";
              }
            }
          };
          textP.appendChild(expandButton);
        } else {
          textP.textContent = fullText;
        }

        const actionsDiv = document.createElement("div");
        actionsDiv.className = "comment-actions";
        
        // 답글 아이콘 버튼
        const replyIconButton = document.createElement("button");
        replyIconButton.className = "reply-button";
        replyIconButton.innerHTML = `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.15 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></svg>`;
        replyIconButton.onclick = function(e) {
          e.stopPropagation();
          toggleReplyForm(node.id);
        };
        actionsDiv.appendChild(replyIconButton);
        
        // 답글 작성 폼
        const replyForm = createReplyForm(node.id);
        
        contentDiv.appendChild(authorDiv);
        contentDiv.appendChild(textP);
        contentDiv.appendChild(actionsDiv);
        
        // 대댓글이 있는 경우 "답글 보기" 버튼 추가
        if (node.children.length > 0) {
          const viewRepliesButton = document.createElement("button");
          viewRepliesButton.className = "view-replies-button";
          viewRepliesButton.setAttribute("data-parent-id", node.id);
          const totalReplies = node.getTotalReplyCount();
          viewRepliesButton.textContent = `답글 ${totalReplies}개 보기`;
          viewRepliesButton.onclick = function(e) {
            e.stopPropagation();
            toggleRepliesVisibility(node.id, viewRepliesButton);
          };
          contentDiv.appendChild(viewRepliesButton);
        }
        
        contentDiv.appendChild(replyForm);

        commentDiv.appendChild(img);
        commentDiv.appendChild(contentDiv);
        
        // 대댓글 컨테이너 제거 - 같은 컨테이너에 평면적으로 렌더링하므로 불필요
        
        container.appendChild(commentDiv);
      }
      
      // DFS로 답글 보기/숨기기 토글
      async function toggleRepliesThreadDFS(commentId, node) {
        const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
        if (!commentElement) {
          console.error("댓글 요소를 찾을 수 없습니다:", commentId);
          return;
        }

        let repliesContainer = document.getElementById(`replies-${commentId}`);
        const viewButton = commentElement.querySelector(".view-replies-button");
        
        if (repliesContainer) {
          // 이미 컨테이너가 있는 경우 토글
          const isVisible = repliesContainer.style.display !== "none";
          repliesContainer.style.display = isVisible ? "none" : "block";
          
          if (viewButton) {
            const totalReplies = node.getTotalReplyCount();
            if (isVisible) {
              viewButton.textContent = `답글 ${totalReplies}개 보기`;
              viewButton.classList.remove("expanded");
            } else {
              viewButton.textContent = `답글 숨기기`;
              viewButton.classList.add("expanded");
            }
          }
          
          // 대댓글이 아직 렌더링되지 않은 경우에만 렌더링
          if (!isVisible && repliesContainer.children.length === 0 && node.children.length > 0) {
            node.children.forEach((childNode) => {
              renderCommentNodeDFS(repliesContainer, childNode, true, true);
            });
          }
        } else {
          // 컨테이너가 없으면 생성 (commentDiv에 추가)
          repliesContainer = document.createElement("div");
          repliesContainer.className = "comment-thread comment-replies-container";
          repliesContainer.id = `replies-${commentId}`;
          repliesContainer.style.display = "block";
          // commentDiv에 추가 (contentDiv 다음)
          commentElement.appendChild(repliesContainer);
          
          // 대댓글 렌더링
          if (node.children.length > 0) {
            node.children.forEach((childNode) => {
              renderCommentNodeDFS(repliesContainer, childNode, true, true);
            });
          }
        }
      }

      // 트리 구조를 평면 배열로 변환 (DFS 순회)
      function flattenCommentTree(nodes) {
        let result = [];
        function dfs(node) {
          if (!node) return;
          result.push(node);
          node.children.forEach(child => dfs(child));
        }
        nodes.forEach(root => dfs(root));
        return result;
      }

      // 모든 댓글을 평면 배열로 변환 (재귀) - 호환성 유지
      function getAllCommentsFlat(comments) {
        let result = [];
        comments.forEach(comment => {
          result.push(comment);
          if (comment.replies && comment.replies.length > 0) {
            result = result.concat(getAllCommentsFlat(comment.replies));
          }
        });
        return result;
      }

      // 개별 댓글 렌더링 (기본 화면용 - 1 depth만) - 호환성 유지
      function renderComment(container, comment, showReplies = false) {
        const commentDiv = document.createElement("div");
        commentDiv.className = "comment";
        commentDiv.setAttribute("data-comment-id", comment.id);
        
        // 댓글 클릭 기능 제거 (기본적으로 대댓글이 표시되므로)

        const img = document.createElement("img");
        img.className = "profile-img";
        img.src = comment.writerProfile || "/images/default-profile.png";
        img.onerror = function() {
          this.src = "/images/default-profile.png";
        };

        const contentDiv = document.createElement("div");
        contentDiv.className = "comment-content";
        
        const authorDiv = document.createElement("div");
        authorDiv.className = "comment-author";
        authorDiv.textContent = comment.writerName || "(이름 없음)";
        
        // 긴 댓글 처리
        const textP = document.createElement("p");
        textP.className = "comment-text";
        const maxLength = 200;
        const fullText = comment.comment;
        if (fullText.length > maxLength) {
          const shortText = fullText.substring(0, maxLength);
          textP.innerHTML = `<span class="comment-text-short">${shortText}...</span><span class="comment-text-full" style="display:none">${fullText}</span>`;
          
          const expandButton = document.createElement("button");
          expandButton.className = "expand-comment-button";
          expandButton.textContent = "더보기";
          expandButton.onclick = function(e) {
            e.stopPropagation();
            const shortSpan = textP.querySelector(".comment-text-short");
            const fullSpan = textP.querySelector(".comment-text-full");
            if (shortSpan && fullSpan) {
              if (shortSpan.style.display !== "none") {
                shortSpan.style.display = "none";
                fullSpan.style.display = "inline";
                expandButton.textContent = "숨기기";
              } else {
                shortSpan.style.display = "inline";
                fullSpan.style.display = "none";
                expandButton.textContent = "더보기";
              }
            }
          };
          textP.appendChild(expandButton);
        } else {
          textP.textContent = fullText;
        }

        const actionsDiv = document.createElement("div");
        actionsDiv.className = "comment-actions";
        
        // Twitter/X 스타일 답글 아이콘 버튼
        const replyIconButton = document.createElement("button");
        replyIconButton.className = "reply-button";
        replyIconButton.innerHTML = `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.15 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></svg>`;
        replyIconButton.onclick = function(e) {
          e.stopPropagation();
          toggleReplyForm(comment.id);
        };
        actionsDiv.appendChild(replyIconButton);
        
        // 답글 작성 폼
        const replyForm = createReplyForm(comment.id);
        
        contentDiv.appendChild(authorDiv);
        contentDiv.appendChild(textP);
        contentDiv.appendChild(actionsDiv);
        
        // 답글 보기 버튼 (대댓글이 있을 때만) - actionsDiv 다음에 배치
        if (comment.replies && comment.replies.length > 0) {
          const viewRepliesButton = document.createElement("button");
          viewRepliesButton.className = "view-replies-button";
          viewRepliesButton.textContent = `답글 ${comment.replies.length}개 보기`;
          viewRepliesButton.onclick = async function(e) {
            e.stopPropagation();
            await toggleRepliesThread(comment.id, comment.replies);
          };
          contentDiv.appendChild(viewRepliesButton);
        }
        
        contentDiv.appendChild(replyForm);

        commentDiv.appendChild(img);
        commentDiv.appendChild(contentDiv);
        
        // 12-24 대댓글 컨테이너 생성 (기본적으로 숨김)
        if (comment.replies && comment.replies.length > 0) {
          const repliesContainer = document.createElement("div");
          repliesContainer.className = "comment-thread comment-replies-container"; // 12-24 답글 컨테이너 클래스 추가
          repliesContainer.id = `replies-${comment.id}`;
          repliesContainer.style.display = "none"; // 기본적으로 숨김
          
          commentDiv.appendChild(repliesContainer);
        }
        
        container.appendChild(commentDiv);
      }
      
      // 답글 보기/숨기기 토글 (스레드 형식)
      async function toggleRepliesThread(commentId, replies) {
        const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
        if (!commentElement) return;

        let repliesContainer = document.getElementById(`replies-${commentId}`);
        const viewButton = commentElement.querySelector(".view-replies-button");
        
        if (repliesContainer) {
          // 이미 컨테이너가 있는 경우 토글
          const isVisible = repliesContainer.style.display !== "none";
          repliesContainer.style.display = isVisible ? "none" : "block";
          
          if (viewButton) {
            viewButton.textContent = isVisible ? `답글 ${replies.length}개 보기` : `답글 숨기기`;
          }
          
          // 이미 렌더링되어 있으면 리턴
          if (!isVisible && repliesContainer.children.length > 0) {
            return;
          }
        } else {
          // 12-24 컨테이너가 없으면 생성
          repliesContainer = document.createElement("div");
          repliesContainer.className = "comment-thread comment-replies-container"; // 12-24 답글 컨테이너 클래스 추가
          repliesContainer.id = `replies-${commentId}`;
          repliesContainer.style.display = "block";
          commentElement.appendChild(repliesContainer);
        }
        
        // 대댓글이 아직 렌더링되지 않은 경우
        if (repliesContainer.children.length === 0) {
          // 대댓글을 시간 순서대로 정렬 (오래된 것부터)
          const sortedReplies = [...replies].sort((a, b) => {
            const dateA = a.createDate ? new Date(a.createDate).getTime() : 0;
            const dateB = b.createDate ? new Date(b.createDate).getTime() : 0;
            return dateA - dateB;
          });
          
          // 재귀적으로 모든 depth의 replies 렌더링
          function renderRepliesRecursive(container, replies, parentId) {
            // 대댓글을 시간 순서대로 정렬 (오래된 것부터)
            const sortedReplies = [...replies].sort((a, b) => {
              const dateA = a.createDate ? new Date(a.createDate).getTime() : 0;
              const dateB = b.createDate ? new Date(b.createDate).getTime() : 0;
              return dateA - dateB;
            });
            
            sortedReplies.forEach((reply) => {
              const replyDiv = document.createElement("div");
              replyDiv.className = "comment comment-reply";
              replyDiv.setAttribute("data-comment-id", reply.id);
              replyDiv.setAttribute("data-parent-id", parentId);
              
              const replyImg = document.createElement("img");
              replyImg.className = "profile-img";
              replyImg.src = reply.writerProfile || "/images/default-profile.png";
              replyImg.onerror = function() {
                this.src = "/images/default-profile.png";
              };
              
              const replyContentDiv = document.createElement("div");
              replyContentDiv.className = "comment-content";
              
              // Twitter/X 스타일 작성자 정보
              const replyAuthorDiv = document.createElement("div");
              replyAuthorDiv.className = "comment-author";
              
              const replyAuthorNameSpan = document.createElement("span");
              replyAuthorNameSpan.className = "comment-author-name";
              replyAuthorNameSpan.textContent = reply.writerName || "(이름 없음)";
              
              const replyTimeSpan = document.createElement("span");
              replyTimeSpan.className = "comment-time";
              const replyCreatedDate = reply.createDate ? new Date(reply.createDate) : new Date();
              replyTimeSpan.textContent = getTimeAgo(replyCreatedDate);
              
              replyAuthorDiv.appendChild(replyAuthorNameSpan);
              replyAuthorDiv.appendChild(replyTimeSpan);
              
              const replyTextP = document.createElement("p");
              replyTextP.className = "comment-text";
              replyTextP.textContent = reply.comment;
              
              // 대댓글에는 답글 버튼과 폼 제거
              
              replyContentDiv.appendChild(replyAuthorDiv);
              replyContentDiv.appendChild(replyTextP);
              
              replyDiv.appendChild(replyImg);
              replyDiv.appendChild(replyContentDiv);
              
              container.appendChild(replyDiv);
              
              // 재귀적으로 답글의 답글도 렌더링 (정렬된 순서로)
              if (reply.replies && reply.replies.length > 0) {
                const sortedNestedReplies = [...reply.replies].sort((a, b) => {
                  const dateA = a.createDate ? new Date(a.createDate).getTime() : 0;
                  const dateB = b.createDate ? new Date(b.createDate).getTime() : 0;
                  return dateA - dateB;
                });
                renderRepliesRecursive(container, sortedNestedReplies, reply.id);
              }
            });
          }
          
          renderRepliesRecursive(repliesContainer, sortedReplies, commentId);
        }
      }

      // 답글 보기/숨기기 토글
      function toggleReplies(commentId, replies) {
        const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
        if (!commentElement) return;

        let repliesContainer = document.getElementById(`replies-${commentId}`);
        
        if (repliesContainer) {
          // 컨테이너가 이미 있는 경우
          const isVisible = repliesContainer.style.display !== "none";
          
          if (isVisible) {
            // 숨기기
            repliesContainer.style.display = "none";
            const viewButton = commentElement.querySelector(".view-replies-button");
            if (viewButton) {
              viewButton.textContent = `답글 ${replies.length}개 보기`;
            }
          } else {
            // 표시하기
            if (repliesContainer.children.length === 0) {
              // 대댓글이 아직 로드되지 않은 경우 로드
              replies.forEach((reply) => {
                const parentCommentData = originalComments.get(commentId) || { id: commentId };
                renderComment(repliesContainer, reply, parentCommentData, true, 1);
              });
            }
            repliesContainer.style.display = "block";
            const viewButton = commentElement.querySelector(".view-replies-button");
            if (viewButton) {
              viewButton.textContent = `답글 숨기기`;
            }
          }
        } else {
          // 12-24 컨테이너가 없는 경우 생성 (이론적으로는 발생하지 않아야 함)
          repliesContainer = document.createElement("div");
          repliesContainer.className = "comment-thread comment-replies-container"; // 12-24 답글 컨테이너 클래스 추가
          repliesContainer.id = `replies-${commentId}`;
          repliesContainer.style.marginTop = "12px";
          
          replies.forEach((reply) => {
            const parentCommentData = originalComments.get(commentId) || { id: commentId };
            renderComment(repliesContainer, reply, parentCommentData, true, 1);
          });
          
          commentElement.appendChild(repliesContainer);
          
          const viewButton = commentElement.querySelector(".view-replies-button");
          if (viewButton) {
            viewButton.textContent = `답글 숨기기`;
          }
        }
      }

      // 댓글 카드 클릭 시 대댓글 표시/숨김
      function toggleCommentReplies(commentId, replies) {
        const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
        if (!commentElement) return;

        let repliesContainer = document.getElementById(`replies-${commentId}`);
        
        if (repliesContainer) {
          // 이미 컨테이너가 있는 경우 토글
          const isVisible = repliesContainer.style.display !== "none";
          repliesContainer.style.display = isVisible ? "none" : "block";
          return;
        }
        
        // 대댓글이 없으면 API에서 로드
        if (!replies || replies.length === 0) {
          // 서버에서 대댓글 로드
          loadRepliesFromServer(commentId);
          return;
        }
        
        // 12-24 대댓글 컨테이너 생성 (스레드 형식)
        repliesContainer = document.createElement("div");
        repliesContainer.className = "comment-thread comment-replies-container"; // 12-24 답글 컨테이너 클래스 추가
        repliesContainer.id = `replies-${commentId}`;
        repliesContainer.style.display = "block"; // 표시
        
        // 재귀적으로 모든 depth의 replies 렌더링
        function renderRepliesRecursive(container, replies) {
          replies.forEach((reply) => {
            const replyDiv = document.createElement("div");
            replyDiv.className = "comment comment-reply";
            replyDiv.setAttribute("data-comment-id", reply.id);
            replyDiv.setAttribute("data-parent-id", commentId);
            
            const replyImg = document.createElement("img");
            replyImg.className = "profile-img";
            replyImg.src = reply.writerProfile || "/images/default-profile.png";
            replyImg.onerror = function() {
              this.src = "/images/default-profile.png";
            };
            
            const replyContentDiv = document.createElement("div");
            replyContentDiv.className = "comment-content";
            
            // Twitter/X 스타일 작성자 정보
            const replyAuthorDiv = document.createElement("div");
            replyAuthorDiv.className = "comment-author";
            
            const replyAuthorNameSpan = document.createElement("span");
            replyAuthorNameSpan.className = "comment-author-name";
            replyAuthorNameSpan.textContent = reply.writerName || "(이름 없음)";
            
            const replyTimeSpan = document.createElement("span");
            replyTimeSpan.className = "comment-time";
            const replyCreatedDate = reply.createDate ? new Date(reply.createDate) : new Date();
            replyTimeSpan.textContent = getTimeAgo(replyCreatedDate);
            
            replyAuthorDiv.appendChild(replyAuthorNameSpan);
            replyAuthorDiv.appendChild(replyTimeSpan);
            
            const replyTextP = document.createElement("p");
            replyTextP.className = "comment-text";
            replyTextP.textContent = reply.comment;
            
            const replyActionsDiv = document.createElement("div");
            replyActionsDiv.className = "comment-actions";
            
            const replyIconBtn = document.createElement("button");
            replyIconBtn.className = "reply-button";
            replyIconBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.15 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></svg>`;
            replyIconBtn.onclick = function(e) {
              e.stopPropagation();
              toggleReplyForm(reply.id);
            };
            replyActionsDiv.appendChild(replyIconBtn);
            
            const replyForm = createReplyForm(reply.id);
            
            replyContentDiv.appendChild(replyAuthorDiv);
            replyContentDiv.appendChild(replyTextP);
            replyContentDiv.appendChild(replyActionsDiv);
            replyContentDiv.appendChild(replyForm);
            
            replyDiv.appendChild(replyImg);
            replyDiv.appendChild(replyContentDiv);
            
            container.appendChild(replyDiv);
            
            // 재귀적으로 답글의 답글도 렌더링
            if (reply.replies && reply.replies.length > 0) {
              renderRepliesRecursive(container, reply.replies);
            }
          });
        }
        
        renderRepliesRecursive(repliesContainer, replies);
        commentElement.appendChild(repliesContainer);
      }

      // 서버에서 대댓글 로드
      async function loadRepliesFromServer(commentId) {
        try {
          if (!currentPostId || currentPostId.trim() === '') {
            console.error("유효하지 않은 게시물 ID입니다.");
            return;
          }
          // 전체 댓글 목록을 가져와서 해당 댓글의 replies 찾기
          const encodedPostId = encodeURIComponent(currentPostId.trim());
          const response = await fetch(`/api/posts/${encodedPostId}/comments?all=true`);
          if (!response.ok) {
            console.error("댓글 로드 실패:", response.status);
            return;
          }
          
          const allComments = await response.json();
          
          // 해당 댓글 찾기
          function findCommentById(comments, id) {
            for (const comment of comments) {
              if (comment.id === id) {
                return comment;
              }
              if (comment.replies && comment.replies.length > 0) {
                const found = findCommentById(comment.replies, id);
                if (found) return found;
              }
            }
            return null;
          }
          
          const targetComment = findCommentById(allComments, commentId);
          if (!targetComment || !targetComment.replies || targetComment.replies.length === 0) {
            return;
          }
          
          const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
          if (!commentElement) return;
          
          let repliesContainer = document.getElementById(`replies-${commentId}`);
          if (!repliesContainer) {
            repliesContainer = document.createElement("div");
            repliesContainer.className = "comment-thread comment-replies-container"; // 12-24 답글 컨테이너 클래스 추가
            repliesContainer.id = `replies-${commentId}`;
            repliesContainer.style.display = "block";
            commentElement.appendChild(repliesContainer);
          }
          
          // 재귀적으로 모든 depth의 replies 렌더링
          function renderRepliesRecursive(container, replies) {
            replies.forEach((reply) => {
              const replyDiv = document.createElement("div");
              replyDiv.className = "comment comment-reply";
              replyDiv.setAttribute("data-comment-id", reply.id);
              replyDiv.setAttribute("data-parent-id", commentId);
              
              const replyImg = document.createElement("img");
              replyImg.className = "profile-img";
              replyImg.src = reply.writerProfile || "/images/default-profile.png";
              replyImg.onerror = function() {
                this.src = "/images/default-profile.png";
              };
              
              const replyContentDiv = document.createElement("div");
              replyContentDiv.className = "comment-content";
              
              // Twitter/X 스타일 작성자 정보
              const replyAuthorDiv = document.createElement("div");
              replyAuthorDiv.className = "comment-author";
              
              const replyAuthorNameSpan = document.createElement("span");
              replyAuthorNameSpan.className = "comment-author-name";
              replyAuthorNameSpan.textContent = reply.writerName || "(이름 없음)";
              
              const replyTimeSpan = document.createElement("span");
              replyTimeSpan.className = "comment-time";
              const replyCreatedDate = reply.createDate ? new Date(reply.createDate) : new Date();
              replyTimeSpan.textContent = getTimeAgo(replyCreatedDate);
              
              replyAuthorDiv.appendChild(replyAuthorNameSpan);
              replyAuthorDiv.appendChild(replyTimeSpan);
              
              const replyTextP = document.createElement("p");
              replyTextP.className = "comment-text";
              replyTextP.textContent = reply.comment;
              
              // 대댓글에는 답글 버튼과 폼 제거
              
              replyContentDiv.appendChild(replyAuthorDiv);
              replyContentDiv.appendChild(replyTextP);
              
              replyDiv.appendChild(replyImg);
              replyDiv.appendChild(replyContentDiv);
              
              container.appendChild(replyDiv);
              
              // 재귀적으로 답글의 답글도 렌더링
              if (reply.replies && reply.replies.length > 0) {
                renderRepliesRecursive(container, reply.replies);
              }
            });
          }
          
          renderRepliesRecursive(repliesContainer, targetComment.replies);
        } catch (error) {
          console.error("대댓글 로드 오류:", error);
        }
      }

      // 대댓글 지연 로딩 및 표시
      async function loadAndShowReplies(commentId, replies) {
        const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
        if (!commentElement) return;

        let repliesContainer = document.getElementById(`replies-${commentId}`);
        
        if (repliesContainer) {
          // 이미 로드된 경우 토글
          const isVisible = repliesContainer.style.display !== "none";
          repliesContainer.style.display = isVisible ? "none" : "block";
          
          const viewButton = commentElement.querySelector(".view-replies-button");
          if (viewButton) {
            viewButton.textContent = isVisible ? `답글 ${replies.length}개 보기` : `답글 숨기기`;
          }
          return;
        }
        
        // 12-24 대댓글 컨테이너 생성 (스레드 형식)
        repliesContainer = document.createElement("div");
        repliesContainer.className = "comment-thread comment-replies-container"; // 12-24 답글 컨테이너 클래스 추가
        repliesContainer.id = `replies-${commentId}`;
        
        // 재귀적으로 모든 depth의 replies 렌더링
        function renderRepliesRecursive(container, replies) {
          replies.forEach((reply) => {
            const replyDiv = document.createElement("div");
            replyDiv.className = "comment comment-reply";
            replyDiv.setAttribute("data-comment-id", reply.id);
            replyDiv.setAttribute("data-parent-id", commentId);
            
            const replyImg = document.createElement("img");
            replyImg.className = "profile-img";
            replyImg.src = reply.writerProfile || "/images/default-profile.png";
            replyImg.onerror = function() {
              this.src = "/images/default-profile.png";
            };
            
            const replyContentDiv = document.createElement("div");
            replyContentDiv.className = "comment-content";
            
            // Twitter/X 스타일 작성자 정보
            const replyAuthorDiv = document.createElement("div");
            replyAuthorDiv.className = "comment-author";
            
            const replyAuthorNameSpan = document.createElement("span");
            replyAuthorNameSpan.className = "comment-author-name";
            replyAuthorNameSpan.textContent = reply.writerName || "(이름 없음)";
            
            const replyTimeSpan = document.createElement("span");
            replyTimeSpan.className = "comment-time";
            const replyCreatedDate = reply.createDate ? new Date(reply.createDate) : new Date();
            replyTimeSpan.textContent = getTimeAgo(replyCreatedDate);
            
            replyAuthorDiv.appendChild(replyAuthorNameSpan);
            replyAuthorDiv.appendChild(replyTimeSpan);
            
            const replyTextP = document.createElement("p");
            replyTextP.className = "comment-text";
            replyTextP.textContent = reply.comment;
            
            // 대댓글에는 답글 버튼과 폼 제거
            
            replyContentDiv.appendChild(replyAuthorDiv);
            replyContentDiv.appendChild(replyTextP);
            
            replyDiv.appendChild(replyImg);
            replyDiv.appendChild(replyContentDiv);
            
            container.appendChild(replyDiv);
            
            // 재귀적으로 답글의 답글도 렌더링
            if (reply.replies && reply.replies.length > 0) {
              renderRepliesRecursive(container, reply.replies);
            }
          });
        }
        
        renderRepliesRecursive(repliesContainer, replies);
        commentElement.appendChild(repliesContainer);
        
        const viewButton = commentElement.querySelector(".view-replies-button");
        if (viewButton) {
          viewButton.textContent = `답글 숨기기`;
        }
      }

      // 대댓글 렌더링 (1 depth만)
      function renderReply(container, reply, parentCommentId) {
        const replyDiv = document.createElement("div");
        replyDiv.className = "comment comment-reply";
        replyDiv.setAttribute("data-comment-id", reply.id);
        replyDiv.setAttribute("data-parent-id", parentCommentId);
        
        // 대댓글 클릭 시 Thread View 열기
        replyDiv.classList.add("clickable-comment");
        replyDiv.onclick = function(e) {
          if (!e.target.closest("button") && !e.target.closest("textarea")) {
            openThreadView(reply);
          }
        };

        const img = document.createElement("img");
        img.className = "profile-img";
        img.src = reply.writerProfile || "/images/default-profile.png";
        img.onerror = function() {
          this.src = "/images/default-profile.png";
        };

        const contentDiv = document.createElement("div");
        contentDiv.className = "comment-content";
        
        const authorDiv = document.createElement("div");
        authorDiv.className = "comment-author";
        authorDiv.textContent = reply.writerName || "(이름 없음)";
        
        // 긴 댓글 처리
        const textP = document.createElement("p");
        textP.className = "comment-text";
        const maxLength = 200;
        const fullText = reply.comment;
        if (fullText.length > maxLength) {
          const shortText = fullText.substring(0, maxLength);
          textP.innerHTML = `<span class="comment-text-short">${shortText}...</span><span class="comment-text-full" style="display:none">${fullText}</span>`;
          
          const expandButton = document.createElement("button");
          expandButton.className = "expand-comment-button";
          expandButton.textContent = "더보기";
          expandButton.onclick = function(e) {
            e.stopPropagation();
            const shortSpan = textP.querySelector(".comment-text-short");
            const fullSpan = textP.querySelector(".comment-text-full");
            if (shortSpan && fullSpan) {
              if (shortSpan.style.display !== "none") {
                shortSpan.style.display = "none";
                fullSpan.style.display = "inline";
                expandButton.textContent = "숨기기";
              } else {
                shortSpan.style.display = "inline";
                fullSpan.style.display = "none";
                expandButton.textContent = "더보기";
              }
            }
          };
          textP.appendChild(expandButton);
        } else {
          textP.textContent = fullText;
        }

        const actionsDiv = document.createElement("div");
        actionsDiv.className = "comment-actions";
        
        // 답글 아이콘 버튼
        const replyIconButton = document.createElement("button");
        replyIconButton.className = "reply-button";
        replyIconButton.innerHTML = `<svg class="reply-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.15 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></svg>`;
        replyIconButton.onclick = function(e) {
          e.stopPropagation();
          toggleReplyForm(reply.id);
        };
        actionsDiv.appendChild(replyIconButton);
        
        // 답글 보기 버튼 (depth 2 이상은 Thread View에서만)
        if (reply.replies && reply.replies.length > 0) {
          const viewRepliesButton = document.createElement("button");
          viewRepliesButton.className = "view-replies-button";
          viewRepliesButton.textContent = `답글 ${reply.replies.length}개 보기`;
          viewRepliesButton.onclick = function(e) {
            e.stopPropagation();
            openThreadView(reply); // depth 2 이상은 Thread View로
          };
          actionsDiv.appendChild(viewRepliesButton);
        }
        
        // 답글 작성 폼
        const replyForm = createReplyForm(reply.id);
        
        contentDiv.appendChild(authorDiv);
        contentDiv.appendChild(textP);
        contentDiv.appendChild(actionsDiv);
        contentDiv.appendChild(replyForm);

        replyDiv.appendChild(img);
        replyDiv.appendChild(contentDiv);
        container.appendChild(replyDiv);
      }

      // Thread View 열기
      function openThreadView(comment) {
        currentThreadCommentId = comment.id;
        loadComments(currentPostId, 0, true);
      }

      // Thread View 표시
      async function showThreadView(commentId, allComments) {
        const container = document.getElementById("comments");
        if (!container) return;

        // 전체 댓글에서 해당 댓글 찾기
        const targetComment = findCommentRecursive(allComments, commentId);
        if (!targetComment) {
          console.error("댓글을 찾을 수 없습니다.");
          return;
        }

        container.innerHTML = "";

        const threadContainer = document.createElement("div");
        threadContainer.className = "thread-view";
        threadContainer.id = "thread-view-container";

        // 뒤로가기 버튼
        const backButton = document.createElement("button");
        backButton.className = "thread-back-button";
        backButton.textContent = "← 목록으로";
        backButton.onclick = function() {
          currentThreadCommentId = null;
          loadComments(currentPostId, 0, false);
        };
        threadContainer.appendChild(backButton);

        // Original Tweet (게시물) 표시
        if (currentPost) {
          const originalTweetDiv = document.createElement("div");
          originalTweetDiv.className = "thread-original-tweet";
          originalTweetDiv.innerHTML = `
            <div style="padding: 16px; border-bottom: 1px solid #eff3f4;">
              <div style="font-weight: 600; margin-bottom: 8px;">원본 게시물</div>
              <div>${currentPost.content || ""}</div>
            </div>
          `;
          threadContainer.appendChild(originalTweetDiv);
        }

        // 상위 댓글 경로 찾기 및 표시
        const threadPath = findThreadPath(allComments, commentId);
        if (threadPath && threadPath.length > 0) {
          threadPath.forEach(comment => {
            if (comment.id !== commentId) {
              renderThreadComment(threadContainer, comment, null, 0);
            }
          });
        }

        // 메인 댓글 표시
        renderThreadComment(threadContainer, targetComment, null, 0);

        // 하위 답글들 표시 (모든 depth)
        if (targetComment.replies && targetComment.replies.length > 0) {
          targetComment.replies.forEach((reply) => {
            renderThreadCommentRecursive(threadContainer, reply, targetComment, 1);
          });
        }

        container.appendChild(threadContainer);
      }

      // Thread View용 댓글 렌더링 (모든 depth 표시)
      function renderThreadComment(container, comment, parentComment, depth) {
        const commentDiv = document.createElement("div");
        commentDiv.className = "comment thread-comment";
        commentDiv.setAttribute("data-comment-id", comment.id);
        commentDiv.setAttribute("data-depth", depth);
        
        if (depth > 0) {
          commentDiv.style.marginLeft = `${depth * 40}px`;
          commentDiv.style.borderLeft = "2px solid #eff3f4";
          commentDiv.style.paddingLeft = "12px";
        }

        const img = document.createElement("img");
        img.className = "profile-img";
        img.src = comment.writerProfile || "/images/default-profile.png";
        img.onerror = function() {
          this.src = "/images/default-profile.png";
        };

        const contentDiv = document.createElement("div");
        contentDiv.className = "comment-content";
        
        const authorDiv = document.createElement("div");
        authorDiv.className = "comment-author";
        authorDiv.textContent = comment.writerName || "(이름 없음)";
        
        // 긴 댓글 처리
        const textP = document.createElement("p");
        textP.className = "comment-text";
        const maxLength = 200;
        const fullText = comment.comment;
        if (fullText.length > maxLength) {
          const shortText = fullText.substring(0, maxLength);
          textP.innerHTML = `<span class="comment-text-short">${shortText}...</span><span class="comment-text-full" style="display:none">${fullText}</span>`;
          
          const expandButton = document.createElement("button");
          expandButton.className = "expand-comment-button";
          expandButton.textContent = "더보기";
          expandButton.onclick = function(e) {
            e.stopPropagation();
            const shortSpan = textP.querySelector(".comment-text-short");
            const fullSpan = textP.querySelector(".comment-text-full");
            if (shortSpan && fullSpan) {
              if (shortSpan.style.display !== "none") {
                shortSpan.style.display = "none";
                fullSpan.style.display = "inline";
                expandButton.textContent = "숨기기";
              } else {
                shortSpan.style.display = "inline";
                fullSpan.style.display = "none";
                expandButton.textContent = "더보기";
              }
            }
          };
          textP.appendChild(expandButton);
        } else {
          textP.textContent = fullText;
        }

        const actionsDiv = document.createElement("div");
        actionsDiv.className = "comment-actions";
        
        // 답글 아이콘 버튼
        const replyIconButton = document.createElement("button");
        replyIconButton.className = "reply-button";
        replyIconButton.innerHTML = `<svg class="reply-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.15 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></svg>`;
        replyIconButton.onclick = function(e) {
          e.stopPropagation();
          toggleReplyForm(comment.id);
        };
        actionsDiv.appendChild(replyIconButton);
        
        // 답글 작성 폼
        const replyForm = createReplyForm(comment.id);
        
        contentDiv.appendChild(authorDiv);
        contentDiv.appendChild(textP);
        contentDiv.appendChild(actionsDiv);
        contentDiv.appendChild(replyForm);

        commentDiv.appendChild(img);
        commentDiv.appendChild(contentDiv);
        container.appendChild(commentDiv);
      }

      // Thread View용 재귀 렌더링 (모든 depth)
      function renderThreadCommentRecursive(container, comment, parentComment, depth) {
        renderThreadComment(container, comment, parentComment, depth);
        
        if (comment.replies && comment.replies.length > 0) {
          comment.replies.forEach((reply) => {
            renderThreadCommentRecursive(container, reply, comment, depth + 1);
          });
        }
      }

      // 댓글 찾기 (재귀)
      function findCommentRecursive(comments, commentId) {
        for (const comment of comments) {
          if (comment.id === commentId) {
            return comment;
          }
          if (comment.replies && comment.replies.length > 0) {
            const found = findCommentRecursive(comment.replies, commentId);
            if (found) return found;
          }
        }
        return null;
      }

      // Thread 경로 찾기 (재귀)
      function findThreadPath(allComments, targetId, path = []) {
        for (const comment of allComments) {
          if (comment.id === targetId) {
            return path;
          }
          if (comment.replies && comment.replies.length > 0) {
            const found = findThreadPath(comment.replies, targetId, [...path, comment]);
            if (found !== null) return found;
          }
        }
        return null;
      }

      // 재귀적으로 댓글 렌더링 (Thread View용, 모든 depth)
      function renderCommentRecursive(container, comment, parentComment, depth) {
        renderComment(container, comment, parentComment, true, depth);
        
        if (comment.replies && comment.replies.length > 0) {
          comment.replies.forEach((reply) => {
            renderCommentRecursive(container, reply, comment, depth + 1);
          });
        }
      }

      // 무한 스크롤 설정
      function setupInfiniteScroll() {
        // 기존 이벤트 리스너 제거
        window.removeEventListener('scroll', handleScroll);
        
        // 새로운 이벤트 리스너 추가
        window.addEventListener('scroll', handleScroll);
      }

      function handleScroll() {
        if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 1000) {
          if (hasMoreComments && !isLoadingComments) {
            loadMoreComments();
          }
        }
      }

      // 답글을 메인으로 보여주는 함수
      function showReplyAsMain(replyComment, parentComment) {
        // 현재 댓글 목록 숨기기
        const commentsContainer = document.getElementById("comments");
        if (!commentsContainer) return;

        // 메인 댓글 영역 생성
        const mainReplyDiv = document.createElement("div");
        mainReplyDiv.className = "comment-main-view";
        mainReplyDiv.id = "main-reply-view";

        // 원문 댓글 표시
        const originalDiv = document.createElement("div");
        originalDiv.className = "reply-original-main";
        originalDiv.style.marginBottom = "16px";
        originalDiv.style.padding = "16px";
        originalDiv.style.backgroundColor = "#f7f9f9";
        originalDiv.style.borderRadius = "12px";
        originalDiv.style.borderLeft = "4px solid #1d9bf0";
        originalDiv.style.cursor = "pointer";
        
        const originalHeader = document.createElement("div");
        originalHeader.className = "reply-original-header";
        originalHeader.innerHTML = `<span class="reply-original-author">${parentComment.writerName || "(이름 없음)"}</span> <span>에게 답글</span>`;
        
        const originalText = document.createElement("div");
        originalText.className = "reply-original-text";
        originalText.textContent = parentComment.comment;
        
        originalDiv.appendChild(originalHeader);
        originalDiv.appendChild(originalText);
        originalDiv.onclick = function() {
          // 원문 클릭 시 원래 댓글 목록으로 돌아가기
          loadComments(currentPostId, 0);
        };

        // 답글 메인 표시
        const replyMainDiv = document.createElement("div");
        replyMainDiv.className = "comment";
        replyMainDiv.style.padding = "16px";
        replyMainDiv.style.backgroundColor = "#ffffff";
        replyMainDiv.style.border = "2px solid #1d9bf0";
        replyMainDiv.style.borderRadius = "12px";
        replyMainDiv.style.marginBottom = "16px";

        const replyImg = document.createElement("img");
        replyImg.className = "profile-img";
        replyImg.src = replyComment.writerProfile || "/images/default-profile.png";
        replyImg.onerror = function() {
          this.src = "/images/default-profile.png";
        };

        const replyContentDiv = document.createElement("div");
        replyContentDiv.className = "comment-content";
        
        const replyAuthorDiv = document.createElement("div");
        replyAuthorDiv.className = "comment-author";
        replyAuthorDiv.textContent = replyComment.writerName || "(이름 없음)";
        
        const replyTextP = document.createElement("p");
        replyTextP.className = "comment-text";
        replyTextP.textContent = replyComment.comment;

        const replyActionsDiv = document.createElement("div");
        replyActionsDiv.className = "comment-actions";
        
        const replyIconBtn = document.createElement("button");
        replyIconBtn.className = "reply-button";
        replyIconBtn.innerHTML = `<svg class="reply-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.15 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></svg>`;
        replyIconBtn.onclick = function(e) {
          e.stopPropagation();
          toggleReplyForm(replyComment.id);
        };
        replyActionsDiv.appendChild(replyIconBtn);

        const replyForm = createReplyForm(replyComment.id);

        replyContentDiv.appendChild(replyAuthorDiv);
        replyContentDiv.appendChild(replyTextP);
        replyContentDiv.appendChild(replyActionsDiv);
        replyContentDiv.appendChild(replyForm);

        replyMainDiv.appendChild(replyImg);
        replyMainDiv.appendChild(replyContentDiv);

        // 12-24 하위 답글들 스레드 형식으로 표시
        if (replyComment.replies && replyComment.replies.length > 0) {
          const repliesThreadContainer = document.createElement("div");
          repliesThreadContainer.className = "comment-thread comment-replies-container"; // 12-24 답글 컨테이너 클래스 추가
          repliesThreadContainer.style.marginLeft = "40px";
          repliesThreadContainer.style.marginTop = "16px";
          repliesThreadContainer.style.paddingTop = "16px";
          repliesThreadContainer.style.borderTop = "1px solid #eff3f4";
          
          replyComment.replies.forEach((nestedReply) => {
            renderComment(repliesThreadContainer, nestedReply, replyComment);
          });
          
          replyContentDiv.appendChild(repliesThreadContainer);
        }

        mainReplyDiv.appendChild(originalDiv);
        mainReplyDiv.appendChild(replyMainDiv);

        // 기존 댓글 목록을 메인 답글 뷰로 교체
        commentsContainer.innerHTML = "";
        commentsContainer.appendChild(mainReplyDiv);

        // 스크롤을 맨 위로
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }

      // 답글 작성 폼 생성 (공통 함수)
      function createReplyForm(commentId) {
        const replyForm = document.createElement("div");
        replyForm.className = "reply-form";
        replyForm.id = `reply-form-${commentId}`;
        
        const replyTextarea = document.createElement("textarea");
        replyTextarea.className = "reply-textarea";
        replyTextarea.placeholder = "답글을 입력하세요...";
        
        const replyButtonsDiv = document.createElement("div");
        replyButtonsDiv.className = "reply-buttons";
        
        const replySubmitButton = document.createElement("button");
        replySubmitButton.className = "reply-submit-button";
        replySubmitButton.textContent = "등록";
        replySubmitButton.onclick = function(e) {
          e.stopPropagation();
          submitReply(commentId, replyTextarea.value);
        };
        
        const replyCancelButton = document.createElement("button");
        replyCancelButton.className = "reply-cancel-button";
        replyCancelButton.textContent = "취소";
        replyCancelButton.onclick = function(e) {
          e.stopPropagation();
          toggleReplyForm(commentId);
        };
        
        replyButtonsDiv.appendChild(replySubmitButton);
        replyButtonsDiv.appendChild(replyCancelButton);
        
        replyForm.appendChild(replyTextarea);
        replyForm.appendChild(replyButtonsDiv);
        
        return replyForm;
      }

      // 원문 댓글 정보 저장 (답글 아이콘 클릭 시 사용)
      const originalComments = new Map();

      // 답글 아이콘 클릭 시 원문 표시/숨김
      function toggleOriginalComment(commentId) {
        const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
        if (!commentElement) return;

        let originalDiv = commentElement.querySelector('.reply-original');
        
        if (originalDiv) {
          // 이미 원문이 표시되어 있으면 숨김
          originalDiv.remove();
        } else {
          // 원문 표시
          const originalComment = originalComments.get(commentId);
          if (originalComment) {
            originalDiv = createOriginalCommentDiv(originalComment);
            const contentDiv = commentElement.querySelector('.comment-content');
            if (contentDiv) {
              contentDiv.insertBefore(originalDiv, contentDiv.firstChild);
            }
          }
        }
      }

      // 원문 댓글 표시 영역 생성
      function createOriginalCommentDiv(originalComment) {
        const originalDiv = document.createElement("div");
        originalDiv.className = "reply-original";
        originalDiv.onclick = function() {
          // 원문 클릭 시 해당 댓글로 스크롤
          const originalElement = document.querySelector(`[data-comment-id="${originalComment.id}"]`);
          if (originalElement) {
            originalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        };

        const headerDiv = document.createElement("div");
        headerDiv.className = "reply-original-header";
        headerDiv.innerHTML = `<span class="reply-original-author">${originalComment.writerName || "(이름 없음)"}</span> <span>에게 답글</span>`;

        const textDiv = document.createElement("div");
        textDiv.className = "reply-original-text";
        textDiv.textContent = originalComment.comment;

        originalDiv.appendChild(headerDiv);
        originalDiv.appendChild(textDiv);

        return originalDiv;
      }

      // 댓글 클릭 시 메인 댓글로 설정하고 답글 표시
      function setMainComment(commentId) {
        currentThreadCommentId = commentId;
        // Thread View로 이동
        loadComments(currentPostId, 0, true);
      }

      // 댓글 클릭 이벤트 핸들러
      function handleCommentClick(commentId, event) {
        // 버튼 클릭이 아닌 경우에만 메인 댓글로 설정
        if (!event.target.closest("button") && !event.target.closest("textarea")) {
          setMainComment(commentId);
        }
      }

      // 답글 폼 토글
      function toggleReplyForm(commentId) {
        const replyForm = document.getElementById(`reply-form-${commentId}`);
        if (replyForm) {
          replyForm.classList.toggle("active");
          if (replyForm.classList.contains("active")) {
            const textarea = replyForm.querySelector(".reply-textarea");
            if (textarea) {
              textarea.focus();
            }
          } else {
            const textarea = replyForm.querySelector(".reply-textarea");
            if (textarea) {
              textarea.value = "";
            }
          }
        }
      }

      // 답글 작성
      async function submitReply(parentCommentId, replyContent) {
        if (!replyContent || replyContent.trim() === "") {
          alert("답글 내용을 입력해주세요.");
          return;
        }

        const userEmail = await getMemberEmail();
        if (!userEmail) {
          openLoginModal();
          return;
        }

        const data = {
          comment: replyContent,
          user: userEmail,
          article: currentPostId,
          parentCommentId: parentCommentId
        };

        try {
          if (!currentPostId || currentPostId.trim() === '') {
            alert("유효하지 않은 게시물 ID입니다.");
            return;
          }
          const encodedPostId = encodeURIComponent(currentPostId.trim());
          const response = await fetch(`/api/posts/${encodedPostId}/comments`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(data),
          });

          if (!response.ok) {
            const errorText = await response.text();
            console.error("답글 저장 실패:", response.status, errorText);
            throw new Error(`답글 저장 실패: ${response.status} ${errorText}`);
          }

          const newReply = await response.json();
          
          // 답글 폼 닫기
          toggleReplyForm(parentCommentId);
          
          // 전체 새로고침으로 겹침 문제 방지
          await loadComments(currentPostId, 0, false);
        } catch (error) {
          console.error("답글 작성 오류:", error);
          alert("답글 저장 중 오류가 발생했습니다.");
        }
      }

      // 시간 표시 함수 (Twitter/X 스타일)
      function getTimeAgo(date) {
        const now = new Date();
        const diff = now - date;
        const seconds = Math.floor(diff / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);
        
        if (seconds < 60) return '방금';
        if (minutes < 60) return `${minutes}분`;
        if (hours < 24) return `${hours}시간`;
        if (days < 7) return `${days}일`;
        
        return date.toLocaleDateString('ko-KR', { month: 'short', day: 'numeric' });
      }

      // 댓글 작성
      async function submitComment() {
        const commentContent = document.getElementById("commentContent").value;
        
        if (!commentContent || commentContent.trim() === "") {
          alert("댓글 내용을 입력해주세요.");
          return;
        }

        const userEmail = await getMemberEmail();
        if (!userEmail) {
          openLoginModal();
          return;
        }

        const data = {
          comment: commentContent,
          user: userEmail,
          article: currentPostId
        };

        try {
          if (!currentPostId || currentPostId.trim() === '') {
            alert("유효하지 않은 게시물 ID입니다.");
            return;
          }
          const encodedPostId = encodeURIComponent(currentPostId.trim());
          const response = await fetch(`/api/posts/${encodedPostId}/comments`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(data),
          });

          if (!response.ok) {
            const errorText = await response.text();
            console.error("댓글 저장 실패:", response.status, errorText);
            throw new Error(`댓글 저장 실패: ${response.status} ${errorText}`);
          }

          const newComment = await response.json();
          
          // 입력 필드 초기화
          document.getElementById("commentContent").value = "";
          
          // 전체 새로고침으로 겹침 문제 방지
          await loadComments(currentPostId, 0, currentThreadCommentId ? true : false);
        } catch (error) {
          console.error("댓글 작성 오류:", error);
          alert("댓글 저장 중 오류가 발생했습니다.");
        }
      }

      // =====================================================
      // 디버깅 함수들 (브라우저 콘솔에서 사용 가능)
      // =====================================================
      
      // 댓글 트리 구조 확인
      window.debugCommentTree = function() {
        console.log("=== 댓글 트리 구조 ===");
        console.log("전체 댓글 트리:", commentTree);
        console.log("댓글 개수:", commentTree.length);
        
        function printTree(nodes, depth = 0) {
          nodes.forEach(node => {
            const indent = "  ".repeat(depth);
            console.log(`${indent}├─ 댓글 ID: ${node.id}, 작성자: ${node.writerName}, 깊이: ${node.depth}, 자식 수: ${node.children.length}`);
            if (node.children.length > 0) {
              printTree(node.children, depth + 1);
            }
          });
        }
        
        printTree(commentTree);
      };
      
      // DOM 구조 확인
      window.debugCommentDOM = function() {
        console.log("=== 댓글 DOM 구조 ===");
        const comments = document.querySelectorAll('.comment');
        console.log(`총 댓글 요소: ${comments.length}개`);
        
        comments.forEach((comment, index) => {
          const commentId = comment.getAttribute('data-comment-id');
          const depth = comment.getAttribute('data-depth');
          const isReply = comment.classList.contains('comment-reply');
          const repliesContainer = comment.querySelector('.comment-replies-container');
          
          console.log(`${index + 1}. 댓글 ID: ${commentId}, 깊이: ${depth}, 대댓글: ${isReply ? '예' : '아니오'}, 답글 컨테이너: ${repliesContainer ? '있음' : '없음'}`);
          
          if (repliesContainer) {
            const replyCount = repliesContainer.children.length;
            const isVisible = repliesContainer.style.display !== 'none';
            console.log(`   └─ 답글 컨테이너: ${replyCount}개 자식, 표시: ${isVisible ? '예' : '아니오'}`);
          }
        });
      };
      
      // 특정 댓글의 구조 확인
      window.debugCommentById = function(commentId) {
        const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
        if (!commentElement) {
          console.error("댓글을 찾을 수 없습니다:", commentId);
          return;
        }
        
        console.log("=== 댓글 상세 정보 ===");
        console.log("요소:", commentElement);
        console.log("클래스:", commentElement.className);
        console.log("깊이:", commentElement.getAttribute('data-depth'));
        console.log("너비:", commentElement.offsetWidth);
        console.log("마진:", {
          left: window.getComputedStyle(commentElement).marginLeft,
          top: window.getComputedStyle(commentElement).marginTop
        });
        
        const repliesContainer = document.getElementById(`replies-${commentId}`);
        if (repliesContainer) {
          console.log("답글 컨테이너:", repliesContainer);
          console.log("답글 컨테이너 너비:", repliesContainer.offsetWidth);
          console.log("답글 컨테이너 마진:", {
            left: window.getComputedStyle(repliesContainer).marginLeft,
            top: window.getComputedStyle(repliesContainer).marginTop
          });
          console.log("답글 개수:", repliesContainer.children.length);
        } else {
          console.log("답글 컨테이너 없음");
        }
      };
      
      // 페이지 로드 시 자동으로 트리 구조 출력
      window.addEventListener('load', function() {
        setTimeout(() => {
          console.log("💡 디버깅 팁: 브라우저 콘솔에서 다음 함수들을 사용하세요:");
          console.log("  - debugCommentTree() : 댓글 트리 구조 확인");
          console.log("  - debugCommentDOM() : DOM 구조 확인");
          console.log("  - debugCommentById(commentId) : 특정 댓글 상세 확인");
        }, 2000);
      });
    </script>
  </body>
</html>

